package fr.bento8.to8.basic;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * @author Benoît Rousseau
 * @version 1.0
 *
 */
public class BasicConverter {

	byte[] basBytes;
	int fileSize;

	public static byte[][] keywords = {
			{0x45, 0x4e, 0x44},	//	0x80	END
			{0x46, 0x4f, 0x52},	//	0x81	FOR
			{0x4e, 0x45, 0x58, 0x54},	//	0x82	NEXT
			{0x44, 0x41, 0x54, 0x41},	//	0x83	DATA
			{0x44, 0x49, 0x4d},	//	0x84	DIM
			{0x52, 0x45, 0x41, 0x44},	//	0x85	READ
			{},	//	0x86	
			{0x47, 0x4f},	//	0x87	GO
			{0x52, 0x55, 0x4e},	//	0x88	RUN	(absent du tableau de pulkomandy)
			{0x49, 0x46},	//	0x89	IF
			{0x52, 0x45, 0x53, 0x54, 0x4f, 0x52, 0x45},	//	0x8A	RESTORE
			{0x52, 0x45, 0x54, 0x55, 0x52, 0x4e},	//	0x8B	RETURN
			{0x27},	//	0x8C	'
			{},	//	0x8D	
			{0x53, 0x54, 0x4f, 0x50},	//	0x8E	STOP
			{0x45, 0x4c, 0x53, 0x45},	//	0x8F	ELSE
			{},	//	0x90	
			{},	//	0x91	
			{},	//	0x92	
			{0x44, 0x45, 0x46, 0x49, 0x4e, 0x54},	//	0x93	DEFINT
			{},	//	0x94	
			{},	//	0x95	
			{0x4f, 0x4e},	//	0x96	ON
			{},	//	0x97	
			{0x45, 0x52, 0x52, 0x4f, 0x52},	//	0x98	ERROR
			{0x52, 0x45, 0x53, 0x55, 0x4d, 0x45},	//	0x99	RESUME
			{},	//	0x9A	
			{},	//	0x9B	
			{0x4c, 0x4f, 0x43, 0x41, 0x54, 0x45},	//	0x9C	LOCATE
			{0x43, 0x4c, 0x53},	//	0x9D	CLS
			{0x43, 0x4f, 0x4e, 0x53, 0x4f, 0x4c, 0x45},	//	0x9E	CONSOLE
			{0x50, 0x53, 0x45, 0x54},	//	0x9F	PSET
			{},	//	0xA0	
			{},	//	0xA1	
			{0x45, 0x58, 0x45, 0x43},	//	0xA2	EXEC
			{0x42, 0x45, 0x45, 0x50},	//	0xA3	BEEP
			{0x43, 0x4f, 0x4c, 0x4f, 0x52},	//	0xA4	COLOR
			{0x4c, 0x49, 0x4e, 0x45},	//	0xA5	LINE
			{0x42, 0x4f, 0x58},	//	0xA6	BOX
			{},	//	0xA7	
			{0x41, 0x54, 0x54, 0x52, 0x42},	//	0xA8	ATTRB
			{0x68, 0x69, 0x70},	//	0xA9	DEF
			{0x50, 0x4f, 0x4b, 0x45},	//	0xAA	POKE
			{0x50, 0x52, 0x49, 0x4e, 0x54},	//	0xAB	PRINT
			{},	//	0xAC	
			{},	//	0xAD	
			{0x43, 0x4c, 0x45, 0x41, 0x52},	//	0xAE	CLEAR
			{},	//	0xAF	
			{0x4b, 0x45, 0x59},	//	0xB0	KEY
			{},	//	0xB1	
			{0x4c, 0x4f, 0x41, 0x44},	//	0xB2	LOAD	(absent du tableau de pulkomandy)
			{0x4c, 0x4f, 0x41, 0x44},	//	0xB3	LOAD
			{},	//	0xB4	
			{0x4f, 0x50, 0x45, 0x4e},	//	0xB5	OPEN
			{0x43, 0x4c, 0x4f, 0x53, 0x45},	//	0xB6	CLOSE
			{0x49, 0x4e, 0x50, 0x45, 0x4e},	//	0xB7	INPEN
			{},	//	0xB8	
			{0x50, 0x4c, 0x41, 0x59},	//	0xB9	PLAY
			{0x54, 0x41, 0x42, 0x28},	//	0xBA	TAB(
			{0x54, 0x4f},	//	0xBB	TO
			{0x53, 0x55, 0x42},	//	0xBC	SUB
			{0x46, 0x4e},	//	0xBD	FN
			{0x53, 0x50, 0x43},	//	0xBE	SPC	(absent du tableau de pulkomandy)	
			{0x55, 0x53, 0x49, 0x4e, 0x47},	//	0xBF	USING
			{},	//	0xC0	
			{0x45, 0x52, 0x4c},	//	0xC1	ERL
			{0x45, 0x52, 0x52},	//	0xC2	ERR
			{},	//	0xC3	
			{0x54, 0x48, 0x45, 0x4e},	//	0xC4	THEN
			{0x4e, 0x4f, 0x54},	//	0xC5	NOT
			{0x53, 0x54, 0x45, 0x50},	//	0xC6	STEP
			{0x2b},	//	0xC7	+
			{0x2d},	//	0xC8	-
			{0x45, 0x4e, 0x44},	//	0xC9	*
			{0x2f},	//	0xCA	/
			{0x5e},	//	0xCB	^	(absent du tableau de pulkomandy)
			{0x41, 0x4e, 0x44},	//	0xCC	AND
			{0x4f, 0x52},	//	0xCD	OR
			{},	//	0xCE	
			{},	//	0xCF	
			{},	//	0xD0	
			{0x4d, 0x4f, 0x44},	//	0xD1	MOD
			{0x40},	//	0xD2	@
			{0x3e},	//	0xD3	>
			{0x3d},	//	0xD4	=
			{0x3c},	//	0xD5	<
			{0x44, 0x53, 0x4b, 0x49, 0x4e, 0x49},	//	0xD6	DSKINI
			{},	//	0xD7	
			{},	//	0xD8	
			{},	//	0xD9	
			{},	//	0xDA	
			{},	//	0xDB	
			{},	//	0xDC	
			{0x50, 0x55, 0x54},	//	0xDD	PUT
			{0x47, 0x45, 0x54},	//	0xDE	GET
			{},	//	0xDF	
			{},	//	0xE0	
			{},	//	0xE1	
			{},	//	0xE2	
			{},	//	0xE3	
			{},	//	0xE4	
			{},	//	0xE5	
			{0x43, 0x4f, 0x50, 0x59},	//	0xE6	COPY
			{},	//	0xE7	
			{},	//	0xE8	
			{},	//	0xE9	
			{},	//	0xEA	
			{},	//	0xEB	
			{},	//	0xEC	
			{},	//	0xED	
			{},	//	0xEE	
			{0x44, 0x4f},	//	0xEF	DO
			{0x4c, 0x4f, 0x4f, 0x50},	//	0xF0	LOOP
			{0x45, 0x58, 0x49, 0x54},	//	0xF1	EXIT
			{},	//	0xF2	
			{},	//	0xF3	
			{},	//	0xF4	
			{},	//	0xF5	
			{},	//	0xF6	
			{},	//	0xF7	
			{0x54, 0x55, 0x52, 0x54, 0x4c, 0x45}	//	0xF8	TURTLE
	};

	public static byte[][] functions = {
			{},	//	0x80	
			{0x49, 0x4e, 0x54},	//	0x81	INT
			{0x41, 0x42, 0x53},	//	0x82	ABS
			{},	//	0x83	
			{},	//	0x84	
			{},	//	0x85	
			{},	//	0x86	
			{},	//	0x87	
			{},	//	0x88	
			{},	//	0x89	
			{0x50, 0x45, 0x45, 0x4b},	//	0x8A	PEEK
			{0x4c, 0x45, 0x4e},	//	0x8B	LEN
			{0x53, 0x54, 0x52, 0x24},	//	0x8C	STR$	(absent du tableau de pulkomandy)
			{0x56, 0x41, 0x4c},	//	0x8D	VAL
			{0x41, 0x53, 0x43},	//	0x8E	ASC
			{0x43, 0x48, 0x52, 0x24},	//	0x8F	CHR$
			{},	//	0x90	
			{},	//	0x91	
			{},	//	0x92	
			{},	//	0x93	
			{},	//	0x94	
			{0x48, 0x45, 0x58, 0x24},	//	0x95	HEX$
			{},	//	0x96	
			{},	//	0x97	
			{},	//	0x98	
			{0x47, 0x52, 0x24},	//	0x99	GR$
			{0x4c, 0x45, 0x46, 0x54, 0x24},	//	0x9A	LEFT$
			{0x52, 0x49, 0x47, 0x48, 0x54, 0x24},	//	0x9B	RIGHT$
			{0x4d, 0x49, 0x44, 0x24},	//	0x9C	MID$
			{},	//	0x9D	
			{0x56, 0x41, 0x52, 0x50, 0x54, 0x52},	//	0x9E	VARPTR
			{0x52, 0x4e, 0x44},	//	0x9F	RND
			{0x49, 0x4e, 0x4b, 0x45, 0x59, 0x24},	//	0xA0	INKEY$
			{0x49, 0x4e, 0x50, 0x55, 0x54, 0x24},	//	0xA1	INPUT$
			{0x43, 0x52, 0x53, 0x4c, 0x49, 0x4e},	//	0xA2	CRSLIN
			{},	//	0xA3	
			{0x53, 0x43, 0x52, 0x45, 0x45, 0x4e},	//	0xA4	SCREEN
			{0x50, 0x4f, 0x53},	//	0xA5	POS
			{0x50, 0x54, 0x52, 0x49, 0x47},	//	0xA6	PTRIG
			{},	//	0xA7	
			{},	//	0xA8	
			{},	//	0xA9	
			{},	//	0xAA	
			{},	//	0xAB	
			{},	//	0xAC	
			{},	//	0xAD	
			{},	//	0xAE	
			{},	//	0xAF	
			{0x53, 0x50, 0x41, 0x43, 0x45, 0x24},	//	0xB0	SPACE$
			{0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x24},	//	0xB1	STRING$
			{0x44, 0x53, 0x4b, 0x49, 0x24},	//	0xB2	DSKI$
			{0x46, 0x4b, 0x45, 0x59, 0x24},	//	0xB3	FKEY$
			{},	//	0xB4	
			{},	//	0xB5	
			{},	//	0xB6	
			{},	//	0xB7	
			{},	//	0xB8	
			{},	//	0xB9	
			{0x50, 0x41, 0x4c, 0x45, 0x54, 0x54, 0x45},	//	0xBA	PALETTE
			{},	//	0xBB	
			{0x48, 0x45, 0x41, 0x44},	//	0xBC	HEAD
			{0x52, 0x4f, 0x54},	//	0xBD	ROT
			{0x53, 0x48, 0x4f, 0x57},	//	0xBE	SHOW
			{0x5a, 0x4f, 0x4f, 0x4d}	//	0xBF	ZOOM
	};

	public BasicConverter() {
	}

	public void load(String fileName) {
		try {
			basBytes = Files.readAllBytes(Paths.get(fileName));										// Lecture de l'en-tête du fichier .bas

			byte fileType = basBytes[0];
			if (fileType != (byte) 0xff) {															// Octet 0   : 0xff (Type du fichier)
				throw new IllegalStateException("Type de fichier non reconnu: Le premier octet "+
						fileType+" n'est pas 0xff");
			}

			fileSize = basBytes[1] << 8 & 0xff00 | basBytes[2] & 0xff;								// Octet 1-2 : Longueur du fichier
			System.out.println("Taille du fichier "+fileName+": "+fileSize+" octets.");

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public byte[] convertToAscii() {

		if (basBytes == null) {
			return null;
		}

		byte[] txtBytes = new byte[basBytes.length*8];												// On réserve de l'espace supplémentaire pour le remplacement des codes par les mots clés
		int i=3, j=0, k, l;																			// La première ligne commence a l'index 3
		int linelength, lineNumber;
		String lineNumberStr;

		while (i+10<basBytes.length) {
			// Lecture ligne à ligne du fichier basic
			linelength = basBytes[i++] << 8 & 0xFF00 | basBytes[i++] & 0xFF;
			lineNumber = basBytes[i++] << 8 & 0xFF00 | basBytes[i++] & 0xFF;
			lineNumberStr = String.valueOf(lineNumber);
			System.out.println("Lecture ligne: "+lineNumberStr+" longueur: "+linelength);

			for (l = 0; l < lineNumberStr.length(); l++) {											// ajout du numéro de ligne
				txtBytes[j++] = (byte) lineNumberStr.charAt(l);
			}
			txtBytes[j++] = (byte) 0x20;															// ajout d'un espace

			while (basBytes[i] != (byte) 0x00) { 													// une fin de ligne se termine par la valeur 0x00
				if (basBytes[i] == (byte) 0x16) { 													// caractères accentués
					if (basBytes[i+1] == (byte) 0x41) { 											// - accent grave
						if (basBytes[i+2] == (byte) 0x61) {txtBytes[j++] = (byte) 0xe0; i+=3;} 		// à
						else if (basBytes[i+2] == (byte) 0x65) {txtBytes[j++] = (byte) 0xe8; i+=3;} // è
						else if (basBytes[i+2] == (byte) 0x75) {txtBytes[j++] = (byte) 0xf6; i+=3;} // ù
					} else if (basBytes[i+1] == (byte) 0x42) { 										// - accent aigu
						if (basBytes[i+2] == (byte) 0x65) {txtBytes[j++] = (byte) 0xe9; i+=3;} 		// é
					} else if (basBytes[i+1] == (byte) 0x43) { 										// - accent circonflexe
						if (basBytes[i+2] == (byte) 0x61) {txtBytes[j++] = (byte) 0xe2; i+=3;}		// â
						else if (basBytes[i+2] == (byte) 0x65) {txtBytes[j++] = (byte) 0xea; i+=3;} // ê
						else if (basBytes[i+2] == (byte) 0x69) {txtBytes[j++] = (byte) 0xee; i+=3;} // î
						else if (basBytes[i+2] == (byte) 0x6f) {txtBytes[j++] = (byte) 0xf4; i+=3;} // ô
						else if (basBytes[i+2] == (byte) 0x75) {txtBytes[j++] = (byte) 0xfb; i+=3;} // û
					} else if (basBytes[i+1] == (byte) 0x48) { 										// - tréma
						if (basBytes[i+2] == (byte) 0x65) {txtBytes[j++] = (byte) 0xeb; i+=3;}		// ë
						else if (basBytes[i+2] == (byte) 0x69) {txtBytes[j++] = (byte) 0xef; i+=3;} // ï
						else if (basBytes[i+2] == (byte) 0x6f) {txtBytes[j++] = (byte) 0xf6; i+=3;} // ö
						else if (basBytes[i+2] == (byte) 0x75) {txtBytes[j++] = (byte) 0xfc; i+=3;} // ü
					} else if (basBytes[i+1] == (byte) 0x4b) { 										// - cédille
						if (basBytes[i+2] == (byte) 0x63) {txtBytes[j++] = (byte) 0xe7; i+=3;} 		// ç
					}
					else {
						System.out.println("Caractère accentué "+
								String.format("0x%02X", basBytes[i])+" "+
								String.format("0x%02X", basBytes[i+1])+" "+
								String.format("0x%02X", basBytes[i+2])+
								" non reconnu.");
						i+=3;}
				} else if (basBytes[i] == (byte) 0xff) {											// Gestion des fonctions Basic
					i++;																			// on se positione après la balise 0xff
					if (basBytes[i] <= (byte) 0xbf && functions[basBytes[i]+128].length > 0) { 		// test de la valeur la plus haute du tableau de correspondance et vérification de la présence d'une valeur
						for (k = 0; k < functions[basBytes[i]+128].length; k++) { 					// +128 positionne la valeur 0x80 à l'index 0 du tableau
							txtBytes[j++] = functions[basBytes[i]+128][k];							// écriture lettre à lettre du nom de fonction
						}
					} else {
						System.out.println("Fonction 0xFF "+
								String.format("0x%02X", basBytes[i])+
								" non reconnue.");
						txtBytes[j++] = basBytes[i];
					}
				} else if (basBytes[i] < (byte) 0xff) { 											// Gestion des mots clés Basic
					if (basBytes[i] <= (byte) 0xf8 && keywords[basBytes[i]+128].length > 0) { 		// test de la valeur la plus haute du tableau de correspondance et vérification de la présence d'une valeur
						for (k = 0; k < keywords[basBytes[i]+128].length; k++) {					// +128 positionne la valeur 0x80 à l'index 0 du tableau
							txtBytes[j++] = keywords[basBytes[i]+128][k];							// écriture lettre à lettre du nom de mot clé
						}
					} else {
						System.out.println("Mot clé "+
								String.format("0x%02X", basBytes[i])+
								" non reconnu.");
						txtBytes[j++] = basBytes[i];
					}
				} else {
					txtBytes[j++] = basBytes[i];													// Caractère sans transcodage
				}
				i++;
			}
			i++;
			txtBytes[j++] = (byte) 0x0d;															// Ajout d'un retour à la ligne
			txtBytes[j++] = (byte) 0x0a;
		}
		System.out.println("Conversion terminée.");
		return txtBytes;
	}	
}