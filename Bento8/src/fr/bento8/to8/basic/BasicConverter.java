package fr.bento8.to8.basic;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

/**
 * @author Benoît Rousseau
 * @version 1.0
 *
 */
public class BasicConverter {

	byte[] basBytes;
	int fileSize;

	public static byte[][] keywords = {
			{0x45, 0x4e, 0x44},	//	0x80	END
			{0x46, 0x4f, 0x52},	//	0x81	FOR
			{0x4e, 0x45, 0x58, 0x54},	//	0x82	NEXT
			{0x44, 0x41, 0x54, 0x41},	//	0x83	DATA
			{0x44, 0x49, 0x4d},	//	0x84	DIM
			{0x52, 0x45, 0x41, 0x44},	//	0x85	READ
			{},	//	0x86	
			{0x47, 0x4f},	//	0x87	GO
			{},	//	0x88	
			{0x49, 0x46},	//	0x89	IF
			{0x52, 0x45, 0x53, 0x54, 0x4f, 0x52, 0x45},	//	0x8A	RESTORE
			{0x52, 0x45, 0x54, 0x55, 0x52, 0x4e},	//	0x8B	RETURN
			{0x27},	//	0x8C	'
			{},	//	0x8D	
			{0x53, 0x54, 0x4f, 0x50},	//	0x8E	STOP
			{0x45, 0x4c, 0x53, 0x45},	//	0x8F	ELSE
			{},	//	0x90	
			{},	//	0x91	
			{},	//	0x92	
			{0x44, 0x45, 0x46, 0x49, 0x4e, 0x54},	//	0x93	DEFINT
			{},	//	0x94	
			{},	//	0x95	
			{0x4f, 0x4e},	//	0x96	ON
			{},	//	0x97	
			{0x45, 0x52, 0x52, 0x4f, 0x52},	//	0x98	ERROR
			{0x52, 0x45, 0x53, 0x55, 0x4d, 0x45},	//	0x99	RESUME
			{},	//	0x9A	
			{},	//	0x9B	
			{0x4c, 0x4f, 0x43, 0x41, 0x54, 0x45},	//	0x9C	LOCATE
			{0x43, 0x4c, 0x53},	//	0x9D	CLS
			{0x43, 0x4f, 0x4e, 0x53, 0x4f, 0x4c, 0x45},	//	0x9E	CONSOLE
			{0x50, 0x53, 0x45, 0x54},	//	0x9F	PSET
			{},	//	0xA0	
			{},	//	0xA1	
			{0x45, 0x58, 0x45, 0x43},	//	0xA2	EXEC
			{0x42, 0x45, 0x45, 0x50},	//	0xA3	BEEP
			{0x43, 0x4f, 0x4c, 0x4f, 0x52},	//	0xA4	COLOR
			{0x4c, 0x49, 0x4e, 0x45},	//	0xA5	LINE
			{0x42, 0x4f, 0x58},	//	0xA6	BOX
			{},	//	0xA7	
			{0x41, 0x54, 0x54, 0x52, 0x42},	//	0xA8	ATTRB
			{0x68, 0x69, 0x70},	//	0xA9	DEF
			{0x50, 0x4f, 0x4b, 0x45},	//	0xAA	POKE
			{0x50, 0x52, 0x49, 0x4e, 0x54},	//	0xAB	PRINT
			{},	//	0xAC	
			{},	//	0xAD	
			{0x43, 0x4c, 0x45, 0x41, 0x52},	//	0xAE	CLEAR
			{},	//	0xAF	
			{0x4b, 0x45, 0x59},	//	0xB0	KEY
			{},	//	0xB1	
			{},	//	0xB2	
			{0x4c, 0x4f, 0x41, 0x44},	//	0xB3	LOAD
			{},	//	0xB4	
			{0x4f, 0x50, 0x45, 0x4e},	//	0xB5	OPEN
			{0x43, 0x4c, 0x4f, 0x53, 0x45},	//	0xB6	CLOSE
			{0x49, 0x4e, 0x50, 0x45, 0x4e},	//	0xB7	INPEN
			{},	//	0xB8	
			{0x50, 0x4c, 0x41, 0x59},	//	0xB9	PLAY
			{0x54, 0x41, 0x42, 0x28},	//	0xBA	TAB(
			{0x54, 0x4f},	//	0xBB	TO
			{0x53, 0x55, 0x42},	//	0xBC	SUB
			{0x46, 0x4e},	//	0xBD	FN
			{},	//	0xBE	
			{0x55, 0x53, 0x49, 0x4e, 0x47},	//	0xBF	USING
			{},	//	0xC0	
			{0x45, 0x52, 0x4c},	//	0xC1	ERL
			{0x45, 0x52, 0x52},	//	0xC2	ERR
			{},	//	0xC3	
			{0x54, 0x48, 0x45, 0x4e},	//	0xC4	THEN
			{0x4e, 0x4f, 0x54},	//	0xC5	NOT
			{0x53, 0x54, 0x45, 0x50},	//	0xC6	STEP
			{0x2b},	//	0xC7	+
			{0x2d},	//	0xC8	-
			{0x45, 0x4e, 0x44},	//	0xC9	*
			{0x2f},	//	0xCA	/
			{},	//	0xCB	
			{0x41, 0x4e, 0x44},	//	0xCC	AND
			{0x4f, 0x52},	//	0xCD	OR
			{},	//	0xCE	
			{},	//	0xCF	
			{},	//	0xD0	
			{0x4d, 0x4f, 0x44},	//	0xD1	MOD
			{0x40},	//	0xD2	@
			{0x3e},	//	0xD3	>
			{0x3d},	//	0xD4	=
			{0x3c},	//	0xD5	<
			{0x44, 0x53, 0x4b, 0x49, 0x4e, 0x49},	//	0xD6	DSKINI
			{},	//	0xD7	
			{},	//	0xD8	
			{},	//	0xD9	
			{},	//	0xDA	
			{},	//	0xDB	
			{},	//	0xDC	
			{0x50, 0x55, 0x54},	//	0xDD	PUT
			{0x47, 0x45, 0x54},	//	0xDE	GET
			{},	//	0xDF	
			{},	//	0xE0	
			{},	//	0xE1	
			{},	//	0xE2	
			{},	//	0xE3	
			{},	//	0xE4	
			{},	//	0xE5	
			{0x43, 0x4f, 0x50, 0x59},	//	0xE6	COPY
			{},	//	0xE7	
			{},	//	0xE8	
			{},	//	0xE9	
			{},	//	0xEA	
			{},	//	0xEB	
			{},	//	0xEC	
			{},	//	0xED	
			{},	//	0xEE	
			{0x44, 0x4f},	//	0xEF	DO
			{0x4c, 0x4f, 0x4f, 0x50},	//	0xF0	LOOP
			{0x45, 0x58, 0x49, 0x54},	//	0xF1	EXIT
			{},	//	0xF2	
			{},	//	0xF3	
			{},	//	0xF4	
			{},	//	0xF5	
			{},	//	0xF6	
			{},	//	0xF7	
			{0x54, 0x55, 0x52, 0x54, 0x4c, 0x45},	//	0xF8	TURTLE
	};

	public static byte[][] functions = {
			{},	//	0x80	
			{0x49, 0x4e, 0x54},	//	0x81	INT
			{0x41, 0x42, 0x53},	//	0x82	ABS
			{},	//	0x83	
			{},	//	0x84	
			{},	//	0x85	
			{},	//	0x86	
			{},	//	0x87	
			{},	//	0x88	
			{},	//	0x89	
			{0x50, 0x45, 0x45, 0x4b},	//	0x8A	PEEK
			{0x4c, 0x45, 0x4e},	//	0x8B	LEN
			{},	//	0x8C	
			{0x56, 0x41, 0x4c},	//	0x8D	VAL
			{0x41, 0x53, 0x43},	//	0x8E	ASC
			{0x43, 0x48, 0x52, 0x24},	//	0x8F	CHR$
			{},	//	0x90	
			{},	//	0x91	
			{},	//	0x92	
			{},	//	0x93	
			{},	//	0x94	
			{0x48, 0x45, 0x58, 0x24},	//	0x95	HEX$
			{},	//	0x96	
			{},	//	0x97	
			{},	//	0x98	
			{0x47, 0x52, 0x24},	//	0x99	GR$
			{0x4c, 0x45, 0x46, 0x54, 0x24},	//	0x9A	LEFT$
			{0x52, 0x49, 0x47, 0x48, 0x54, 0x24},	//	0x9B	RIGHT$
			{0x4d, 0x49, 0x44, 0x24},	//	0x9C	MID$
			{},	//	0x9D	
			{0x56, 0x41, 0x52, 0x50, 0x54, 0x52},	//	0x9E	VARPTR
			{0x52, 0x4e, 0x44},	//	0x9F	RND
			{0x49, 0x4e, 0x4b, 0x45, 0x59, 0x24},	//	0xA0	INKEY$
			{0x49, 0x4e, 0x50, 0x55, 0x54, 0x24},	//	0xA1	INPUT$
			{0x43, 0x52, 0x53, 0x4c, 0x49, 0x4e},	//	0xA2	CRSLIN
			{},	//	0xA3	
			{0x53, 0x43, 0x52, 0x45, 0x45, 0x4e},	//	0xA4	SCREEN
			{0x50, 0x4f, 0x53},	//	0xA5	POS
			{0x50, 0x54, 0x52, 0x49, 0x47},	//	0xA6	PTRIG
			{},	//	0xA7	
			{},	//	0xA8	
			{},	//	0xA9	
			{},	//	0xAA	
			{},	//	0xAB	
			{},	//	0xAC	
			{},	//	0xAD	
			{},	//	0xAE	
			{},	//	0xAF	
			{0x53, 0x50, 0x41, 0x43, 0x45, 0x24},	//	0xB0	SPACE$
			{0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x24},	//	0xB1	STRING$
			{0x44, 0x53, 0x4b, 0x49, 0x24},	//	0xB2	DSKI$
			{0x46, 0x4b, 0x45, 0x59, 0x24},	//	0xB3	FKEY$
			{},	//	0xB4	
			{},	//	0xB5	
			{},	//	0xB6	
			{},	//	0xB7	
			{},	//	0xB8	
			{},	//	0xB9	
			{0x50, 0x41, 0x4c, 0x45, 0x54, 0x54, 0x45},	//	0xBA	PALETTE
			{},	//	0xBB	
			{0x48, 0x45, 0x41, 0x44},	//	0xBC	HEAD
			{0x52, 0x4f, 0x54},	//	0xBD	ROT
			{0x53, 0x48, 0x4f, 0x57},	//	0xBE	SHOW
			{0x5a, 0x4f, 0x4f, 0x4d},	//	0xBF	ZOOM
			{},	//	0xC0	
			{},	//	0xC1	
			{},	//	0xC2	
			{},	//	0xC3	
			{},	//	0xC4	
			{},	//	0xC5	
			{},	//	0xC6	
			{},	//	0xC7	
			{},	//	0xC8	
			{},	//	0xC9	
			{},	//	0xCA	
			{},	//	0xCB	
			{},	//	0xCC	
			{},	//	0xCD	
			{},	//	0xCE	
			{},	//	0xCF	
			{},	//	0xD0	
			{},	//	0xD1	
			{},	//	0xD2	
			{},	//	0xD3	
			{},	//	0xD4	
			{},	//	0xD5	
			{},	//	0xD6	
			{},	//	0xD7	
			{},	//	0xD8	
			{},	//	0xD9	
			{},	//	0xDA	
			{},	//	0xDB	
			{},	//	0xDC	
			{},	//	0xDD	
			{},	//	0xDE	
			{},	//	0xDF	
			{},	//	0xE0	
			{},	//	0xE1	
			{},	//	0xE2	
			{},	//	0xE3	
			{},	//	0xE4	
			{},	//	0xE5	
			{},	//	0xE6	
			{},	//	0xE7	
			{},	//	0xE8	
			{},	//	0xE9	
			{},	//	0xEA	
			{},	//	0xEB	
			{},	//	0xEC	
			{},	//	0xED	
			{},	//	0xEE	
			{},	//	0xEF	
			{},	//	0xF0	
			{},	//	0xF1	
			{},	//	0xF2	
			{},	//	0xF3	
			{},	//	0xF4	
			{},	//	0xF5	
			{},	//	0xF6	
			{},	//	0xF7	
			{}	//	0xF8	
	};

	public BasicConverter() {

	}

	public void load(String fileName) {
		try {
			basBytes = Files.readAllBytes(Paths.get(fileName));

			// Lecture de l'en-tête
			// Octet 0   : 0xff (Type du fichier)
			// Octet 1-2 : Longueur du fichier
			
			byte fileType = basBytes[0];
			if (fileType != (byte) 0xff) {
				throw new IllegalStateException("Type de fichier non reconnu: Le premier octet "+fileType+" n'est pas 0xff");
			}

			fileSize = basBytes[1] << 8 & 0xFF00 | basBytes[2] & 0xFF;
			System.out.println("Taille du fichier "+fileName+": "+fileSize+" octets.");

		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public byte[] convertToAscii() {

		if (basBytes == null) {
			return null;
		}

		byte[] txtBytes = new byte[basBytes.length*8]; // On réserve de l'espace supplémentaire pour le remplacement des codes par les mots clés
		int i=3, j=0, k, l; // La première ligne commence a l'index 3
		int linelength, lineNumber;
		String lineNumberStr;

		while (i+10<basBytes.length) {
			// Lecture ligne à ligne du fichier basic
			linelength = basBytes[i++] << 8 & 0xFF00 | basBytes[i++] & 0xFF;
			lineNumber = basBytes[i++] << 8 & 0xFF00 | basBytes[i++] & 0xFF;
			lineNumberStr = String.valueOf(lineNumber);
			System.out.println("Lecture ligne: "+lineNumberStr+" longueur: "+linelength);

			// Ajout du numéro de ligne et de l'espace
			for (l = 0; l < lineNumberStr.length(); l++) {
				txtBytes[j++] = (byte) lineNumberStr.charAt(l);
			}
			txtBytes[j++] = (byte) 0x20;

			//System.out.println(String.format("%02x", basBytes[i]));

			while (basBytes[i] != (byte) 0x00) { // une fin de ligne se termine par la valeur 0x00

				// Gestion des caractères accentués
				if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x41 && basBytes[i+2] == (byte) 0x61) {txtBytes[j++] = (byte) 0xe0; i+=3;} //à
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x41 && basBytes[i+2] == (byte) 0x65) {txtBytes[j++] = (byte) 0xe8; i+=3;} //è
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x41 && basBytes[i+2] == (byte) 0x75) {txtBytes[j++] = (byte) 0xf6; i+=3;} //ù
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x42 && basBytes[i+2] == (byte) 0x65) {txtBytes[j++] = (byte) 0xe9; i+=3;} //é
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x43 && basBytes[i+2] == (byte) 0x61) {txtBytes[j++] = (byte) 0xe2; i+=3;} //â
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x43 && basBytes[i+2] == (byte) 0x65) {txtBytes[j++] = (byte) 0xea; i+=3;} //ê
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x43 && basBytes[i+2] == (byte) 0x69) {txtBytes[j++] = (byte) 0xee; i+=3;} //î
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x43 && basBytes[i+2] == (byte) 0x6f) {txtBytes[j++] = (byte) 0xf4; i+=3;} //ô
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x43 && basBytes[i+2] == (byte) 0x75) {txtBytes[j++] = (byte) 0xfb; i+=3;} //û
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x48 && basBytes[i+2] == (byte) 0x65) {txtBytes[j++] = (byte) 0xeb; i+=3;} //ë
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x48 && basBytes[i+2] == (byte) 0x69) {txtBytes[j++] = (byte) 0xef; i+=3;} //ï
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x48 && basBytes[i+2] == (byte) 0x6f) {txtBytes[j++] = (byte) 0xf6; i+=3;} //ö
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x48 && basBytes[i+2] == (byte) 0x75) {txtBytes[j++] = (byte) 0xfc; i+=3;} //ü
				else if (basBytes[i] == (byte) 0x16 && basBytes[i+1] == (byte) 0x4b && basBytes[i+2] == (byte) 0x63) {txtBytes[j++] = (byte) 0xe7; i+=3;} //ç
				else if (basBytes[i] == (byte) 0x16) {System.out.println("Caractère accentué "+String.format("0x%02X", basBytes[i])+" "+String.format("0x%02X", basBytes[i+1])+" "+String.format("0x%02X", basBytes[i+2])+" non reconnu."); i+=3;}
				else {
					// Gestion des mots clés Basic
					//System.out.println(String.format("%02x", basBytes[i]));
					if (basBytes[i] <= (byte) 0xf8) { // La table s'arrête a 0xf8
						for (k = 0; k < keywords[basBytes[i]+128].length; k++) {
							txtBytes[j++] = keywords[basBytes[i]+128][k];
						}
					} else if (basBytes[i] == (byte) 0xFF) {
						
						// Gestion des fonctions Basic
						if (basBytes[++i] <= (byte) 0xf8) { // La table s'arrête a 0xf8
							for (k = 0; k < functions[basBytes[i]+128].length; k++) {
								txtBytes[j++] = functions[basBytes[i]+128][k];
							}
						} else {
							throw new IllegalStateException("Fonction non reconnue 0xFF "+String.format("0x%02X", basBytes[i+1])+" non reconnu.");
						}
					} else {
						// Caractère sans transcodage
						txtBytes[j++] = basBytes[i];
					}
					i++;
				}
			}
			i++;
			// Ajout d'un retour à la ligne
			txtBytes[j++] = (byte) 0x0d;
			txtBytes[j++] = (byte) 0x0a;
		}
		return txtBytes;
	}	
}